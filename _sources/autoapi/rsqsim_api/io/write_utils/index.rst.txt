:orphan:

:py:mod:`rsqsim_api.io.write_utils`
===================================

.. py:module:: rsqsim_api.io.write_utils


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   rsqsim_api.io.write_utils.create_quad_mesh_from_fault
   rsqsim_api.io.write_utils.fit_plane_to_points
   rsqsim_api.io.write_utils.get_fault_rotation_matrix
   rsqsim_api.io.write_utils.fault_global_to_local
   rsqsim_api.io.write_utils.fault_local_to_global
   rsqsim_api.io.write_utils.get_quad_mesh_edges
   rsqsim_api.io.write_utils.get_edge
   rsqsim_api.io.write_utils.create_local_grid
   rsqsim_api.io.write_utils.create_cells_from_dims
   rsqsim_api.io.write_utils.tri_interpolate_zcoords
   rsqsim_api.io.write_utils.project_2d_coords
   rsqsim_api.io.write_utils.find_projected_coords
   rsqsim_api.io.write_utils.get_mesh_boundary



.. py:function:: create_quad_mesh_from_fault(points, edges, triangles, resolution = 5000.0, num_search_tris = 10, fit_plane_epsilon = 1e-05, cutoff_rotation_vecmag = 0.98, is_plane_epsilon = 1.0)

   Create a quad mesh, given triangular mesh information.
   Returned values are all in the fault_mesh_info dictionary:
       plane_normal: Normal vector for best-fit plane through original points
       plane_origin: Reference point for best-fit plane through original points
       rotation_matrix: Rotation matrix based on plane_normal
       points_local: Original points transformed to local coordinates
       edges_local: Original edges transformed to local coordinates
       fault_is_plane: Boolean determining whether fault is a plane within given tolerance
       quad_edges: Dictionary containing the 4 edges composing the mesh boundary
       mesh_points_local: The generated mesh points (structured mesh) in local fault coordinates
       num_horiz_points: The number of mesh points in the horizontal direction
       num_vert_points: The number of mesh points in the vertical direction
       mesh_points_global: The generated mesh points (structured mesh) in global coordinates


.. py:function:: fit_plane_to_points(points, eps = 1e-05)

   Find best-fit plane through a set of points, after first insuring the plane goes through
   the mean (centroid) of all the points in the array. This is probably better than my
   initial method, since the SVD is only over a 3x3 array (rather than the num_pointsxnum_points
   array).
   Returned values are:
       plane_normal:  Normal vector to plane (A, B, C)
       plane_origin:  Point on plane that may be considered as the plane origin


.. py:function:: get_fault_rotation_matrix(plane_normal, cutoff_vecmag = 0.98)

   Compute rotation matrix, given the normal to the plane. If the normal is nearly
   vertical an alternate reference direction is used to compute the two tangential
   directions.
   Returned values are:
       rotation_matrix: 3x3 rotation matrix with columns (tan_dir1, tan_dir2, plane_normal).


.. py:function:: fault_global_to_local(points, edges, rotation_matrix, plane_origin, plane_epsilon = 1.0)

   Convert global fault surface coordinates to local coordinates, referenced to given origin.
   If plane z-values are below epsilon value, surface is assumed to be a plane.
   Returned values are:
       points_local: Point coordinates referenced to origin and rotated to local orientation.
       edges_local: Edge coordinates referenced to origin and rotated to local orientation.
       fault_is_plane: Boolean variable that is true if the fault is planar within the given tolerance.


.. py:function:: fault_local_to_global(points, edges, rotation_matrix, plane_origin)

   Convert local fault surface coordinates to global coordinates.
   Returned values are:
       points_global: Point coordinates rotated to global orientation and with origin added back in.
       edges_global: Edge coordinates rotated to global orientation and with origin added back in.


.. py:function:: get_quad_mesh_edges(edges, corner_separation = 3000.0)

   Determine 4 sets of edges, assuming a semi-quadrilateral layout.
   Note that all coordinates are assumed to be fault-local coordinates.
   Uses dot products of line segments with the next segment to determine 4 smallest dot products.
   In the future, we will use the corner_separation parameter to work around 'chopped-off' corners.
   Returned values are contained in the edge_sides dictionary:
       left_edge: Coordinates of edge corresponding to leftmost edge
       right_edge: Coordinates of edge corresponding to rightmost edge
       bottom_edge: Coordinates of edge corresponding to bottommost edge
       top_edge: Coordinates of edge corresponding to topmost edge


.. py:function:: get_edge(edges, ind1, ind2, ind_min, ind_max, sort_ind)

   Extract edge from edges array, given the indices to use.
   Returned value:
       edge:  Edge coordinates, sorted according to the given sorting index


.. py:function:: create_local_grid(points, edge_sides, triangles, fault_is_plane, resolution = 5000.0, num_search_tris = 10)

   Create a grid of points in local coordinates. If the fault is a plane, z-coordinate is
   always zero. Otherwise, points are interpolated from the enclosing triangle vertices.
   Returned values are:
       mesh_points: The computed mesh points in the local coordinate system
       num_horiz_points: The number of points in the horzontal direction
       num_vert_points: The number of points in the vertical direction


.. py:function:: create_cells_from_dims(num_verts_x, num_verts_y)

   Create simple quad cell connectivity array given the vertical and horizontal dimensions.
   Returned values are:
       cell_array: A num_cellsx4 array describing vertices composing each cell


.. py:function:: tri_interpolate_zcoords(points, triangles, mesh_points, is_mesh_edge, num_search_tris = 10)

   Interpolate z-coordinates to a set of 2D points using 3D point coordinates and a triangular mesh.
   If point is along a mesh boundary, the boundary values are used instead.
   Returned values are:
       z: The interpolated z-values


.. py:function:: project_2d_coords(tri_coords, coord, tree, num_search_tris = 10)

   Project z-coordinate for triangle coordinates.
   Returned values are:
       projected_coords[2]: The z-value interpolated from values at triangle vertices


.. py:function:: find_projected_coords(tri_coord, point)

   Find whether a point projects within a triangle, and if so compute the
   projected coordinates.
   Returned values are:
       in_tri: Boolean indicating whether the point is contained in the triangle
       projected_coords: The (x,y,z) coordinates of the point inferred from the triangle values


.. py:function:: get_mesh_boundary(triangles)

   Find outer boundary of a triangulated mesh, assuming no holes.
   Boundary is determined based purely on connectivity.
   Returned values are:
       vert_inds: The indices of the vertices composing the mesh boundary, ordered to be continuous


